この資料は、4目並べ https://github.com/sapporocpp/4moku のAIを作る上での、基本事項のまとめや、「～～するにはどんなコードを書けばよい？」といった事例集です。

# 動かす方法

ビルドは`make`と`SCons`に対応しています。どちらかでもインストールされている環境であれば、まずそれを試してください。またVisual Studio用のプロジェクトファイルもあります。

使うAIを差し替えたい場合は、以下のことを行います。

-   `source/4moku.cpp`の冒頭で、必要なヘッダファイルを追加する。
-   `source/4moku.cpp`の`main`関数内に`std::vector<std::function<FuncType>> ai_list = ...`というコードがあるので、そこを差し替える。
    -   ここでは例にある通り、
        - 1つの関数を呼び出すだけで動くAIの場合は、直接関数ポインタを書く。
        - クラスとして定義されたAI（次に説明します）の場合は、事前にそのインスタンスを生成したうえで、ラムダ式を経由したり`std::bind`を経由したりして呼び出せるようにする。
    -   ここに書かれた全AIが順に手を選ぶことで対戦が進む。
    -   対戦させるAIの件数に制限はなく、また書かれた順で順番が回ってくる。

# AI作成における事例集

## プログラムの構造

AIを定義しているファイル（`source`ディレクトリ内の`*.hpp`ファイル、ただし`4moku.hpp`を除く）をご覧ください。AIは以下の形で呼び出せる必要があります。

```
std::tuple<int, int> AI_FUNCTION(const Board & board, int player);
```

これは必ずしも単独の関数である必要はなく、`test_ai.hpp`などで書かれているように、クラス（構造体）のメソッドであっても構いません。クラスを通すことでメンバ変数を利用できる、つまり一度使った結果を以後の手を選ぶときにも利用できるという利点があります。（例えば、乱数生成器を最初に一回用意してあとはそれを使い続ける、一度先読みした相手の手を残して次に使う、など）

返り値の型になっている`tuple`はC++11で規格化されたクラスで、複数の値をひとまとめにしたデータを表現するのに用います。  
参考：[tuple - cpprefjp C++日本語リファレンス](http://cpprefjp.github.io/reference/tuple/tuple.html "tuple - cpprefjp C++日本語リファレンス")  
この`tuple`型の値を生成するための関数が`std::make_tuple(a, b)`です（AIのコード中でもたびたび使われています）。これがあると、`tuple`のインスタンスを作るのに、クラス名（`std::tuple<int, int>`）を明示しなくても引数の型から自動的に判断してくれます。

## API

-   `board(x, y)` （boardはBoardクラスのインスタンス）
    -   (x, y)の地点にある石を得る。石がなければ0を返す。石の値を代入することもできる（盤面の変化をシミュレーションする場合など）。
-   `board.size()` （boardはBoardクラスのインスタンス）
    -   盤面の大きさを得る。次の例を参照。
-   `board.players()` （boardはBoardクラスのインスタンス）
    -   現在何人でプレーしているかを得る。
-   `player_id(player)`
    -   プレイヤーを指定し、そのプレイヤーの石を取得する。`board(x, y) == player_id(player)`のように比較することで、誰の石かがわかる。
-   `placeable(board, x, y)`
    -   (x, y)の地点に石が置けるかを返す。
-   `finished(board)`
    -   ゲームが決着していた場合、その石を返す。決着していなければ0を返す。

## まずは単純な例：ランダムに置く

サンプルコード：`test_ai.hpp`

単純な例として、「ランダムな場所に置く」というものを考えます。

まず、乱数を生成しないとなりませんが、その前に盤面のサイズを知らなければ、適切な乱数を生成することもできません。それを取得するのが次のコードです。

	int nx,ny;
	std::tie(nx,ny) = board.size();

では、乱数を生成するのに必要な準備をします。ここではC++で規格化された乱数ライブラリを使います。

	std::random_device rd;
	std::mt19937 mt(rd());
	std::uniform_int_distribution<> rndx(0, nx);
	std::uniform_int_distribution<> rndy(0, ny);

`rndx`は0以上nx未満の整数を、`rndy`は0以上ny未満の整数を生成します。

続いて、乱数を生成し、その場所に石を置くことにします。

	int x = rndx(mt), y = rndy(mt);
	return std::make_tuple(x, y);

ところがこれでは、置けない場所（すでに石がある場所、あるいは置いても石が落ちていってしまう場所）に置いてしまう可能性があります。そこで、石を置ける場所なのかチェックを入れて、それが大丈夫だったときに初めて置くようにします。

	int x = rndx(mt), y = rndy(mt);
	if(placeable(board, x, y)){
		return std::make_tuple(x, y);
	}

またそのため、石を置けなかった場合には再度置く場所を乱数で選びたいので、ループの中に入れます。

	for(int i=0;i<300;++i) {
		int x = rndx(mt), y = rndy(mt);
		if(placeable(board, x, y)){
			return std::make_tuple(x, y);
		}
	}

乱数の生成は、C言語にもある`rand`を使う方法のほか、上述した例にある、C++11で規格化された乱数ライブラリを使う方法があります。  
参考：[random - cpprefjp C++日本語リファレンス](http://cpprefjp.github.io/reference/random.html "random - cpprefjp C++日本語リファレンス")

C++11の乱数は、「乱数の生成方法」「それにより生成される分布（指定区間の整数とか、指定区間のdouble値とか）」のそれぞれについてクラスが定義されており、これらを選んで乱数を生成します。この例では、乱数の生成方法として`std::mt19937`、それにより生成される分布として`std::uniform_int_distribution`（指定された範囲の整数から無作為選択）を使っています。

## もっとAIらしい例：何らかの基準で置く場所を選ぶ

さてここからは、もっとAIらしくするために、「何らかの基準で置く場所を選ぶ」ものを作ってみます。

基本的な構造は以下の通りです。

    std::tuple<int,int> choice; // 現時点での置き場所
    
	for(int i = 0; i < nx; ++i){
		for(int j = 0; j < ny; ++j){
			if(placeable(board, i, j)) break;
    
            // ここで、何らかの基準で置き場所を選び
            // choiceに代入する
        }
    }
    return choice;

`placeable`関数を用いて、その場所に置けないのであれば最初から検討は行わないことにします。

例えば、「置ける場所を順に探して、最初に見つかった場所に置く」というコードは以下のようになります。

	for(int i = 0; i < nx; ++i){
		for(int j = 0; j < ny; ++j){
			if(placeable(board, i, j)) break;
            return std::make_tuple(i, j);
        }
    }

### 自分の石が並んでいる場所を伸ばす/自分が置いたら勝てる場所に置く

サンプルコード：`chain.hpp`, `winning.hpp`

自分の石を4つ並べればよいため、「なるべく自分の石が多く並ぶ」ようにするのは有効な戦術といえます。

この実装は力技に近くて、

- 各マス目を起点に、
- 4方向に見る向きを伸ばし（実際は8方向あるが、例えば「上への繋がりを見ていく」ことと「下への繋がりを見ていく」ことは片方だけ行えばよいため）、
- 何個繋がっているか調べる

というものになります。

### 相手の手を1手だけ先読みする

サンプルコード：`kakutei.hpp`

この例は、上述の「自分が置いたら勝てる場所に置く」に、「自分が置いたら次に相手が勝てるような場所には置かない」という条件を組み込んでいます。

手を先読みするには、

-   現在の盤面をコピーして（`Board b_tmp(b);`の部分がそう）、
-   実際に石を置く（`board_tmp(i, j) = player_id(player);`の部分がそう）

という手順になります。先読みするそれぞれの一手につき、盤面のコピーを行うことになります。
